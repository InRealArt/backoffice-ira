'use client'

import { useState, useRef, useEffect } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { artworkSchema, ArtworkFormData } from '../createArtwork/schema'
import { createArtwork } from '@/lib/actions/shopify-actions'
import toast from 'react-hot-toast'
import { useDynamicContext } from '@dynamic-labs/sdk-react-core'
import styles from './ArtworkForm.module.scss'
import { getBackofficeUserByEmail, createItemRecord, saveAuthCertificate } from '@/lib/actions/prisma-actions'
import { pdfjs } from 'react-pdf'
import { Document, Page } from 'react-pdf'
import 'react-pdf/dist/esm/Page/AnnotationLayer.css'
import 'react-pdf/dist/esm/Page/TextLayer.css'
import { TagInput } from '@/app/components/Tag/TagInput'
import { normalizeString } from '@/lib/utils'
// Imports qui causent des erreurs - à supprimer
// import { Button } from '@/components/ui/button'
// import { Loader2Icon, UploadIcon, XIcon } from 'lucide-react'
// import { useRouter } from 'next/navigation'

// Configuration du worker PDF.js (nécessaire pour react-pdf)
pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.min.js`

// Composant InfoTooltip pour afficher des conseils détaillés
interface InfoTooltipProps {
  title: string;
  content: React.ReactNode;
}

function InfoTooltip({ title, content }: InfoTooltipProps) {
  const [isOpen, setIsOpen] = useState(false);
  const tooltipRef = useRef<HTMLDivElement>(null);

  // Fermer l'infobulle en cliquant à l'extérieur
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (tooltipRef.current && !tooltipRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  return (
    <div className={styles.tooltipContainer} ref={tooltipRef}>
      <span 
        className={styles.infoIcon} 
        onClick={() => setIsOpen(!isOpen)}
        aria-label={title}
      >
        ?
      </span>
      {isOpen && (
        <div className={styles.tooltipContent}>
          <div className={styles.tooltipHeader}>
            <h4>{title}</h4>
            <button 
              className={styles.closeTooltip}
              onClick={() => setIsOpen(false)}
              aria-label="Fermer"
            >
              ×
            </button>
          </div>
          <div className={styles.tooltipBody}>
            {content}
          </div>
        </div>
      )}
    </div>
  );
}

interface ArtworkFormProps {
  mode: 'create' | 'edit';
  initialData?: {
    id?: number;
    title?: string;
    description?: string;
    price?: number;
    metaTitle?: string;
    metaDescription?: string;
    medium?: string;
    width?: string;
    height?: string;
    weight?: string;
    year?: string;
    creationYear?: string;
    intellectualProperty?: boolean;
    intellectualPropertyEndDate?: string;
    edition?: string;
    imageUrl?: string;
    hasPhysicalOnly?: boolean;
    hasNftOnly?: boolean;
    hasNftPlusPhysical?: boolean;
    pricePhysicalBeforeTax?: string;
    priceNftBeforeTax?: string;
    priceNftPlusPhysicalBeforeTax?: string;
    slug?: string;
  };
  onSuccess?: () => void;
}

export default function ArtworkForm({ mode = 'create', initialData = {}, onSuccess }: ArtworkFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [previewImages, setPreviewImages] = useState<string[]>([])
  const [previewCertificate, setPreviewCertificate] = useState<string | null>(null)
  const [numPages, setNumPages] = useState<number | null>(null)
  const [tags, setTags] = useState<string[]>([])
  const [hasIntellectualProperty, setHasIntellectualProperty] = useState(initialData?.intellectualProperty || false)
  const [slug, setSlug] = useState(initialData?.slug || '')
  const fileInputRef = useRef<HTMLInputElement>(null)
  const certificateInputRef = useRef<HTMLInputElement>(null)
  const secondaryImagesInputRef = useRef<HTMLInputElement>(null)
  const [secondaryImages, setSecondaryImages] = useState<string[]>([])
  const { user } = useDynamicContext()
  const [formErrors, setFormErrors] = useState<any>(null)
  const isEditMode = mode === 'edit'
  
  // Log pour vérifier les données initiales
  useEffect(() => {
    if (isEditMode) {
      console.log('ArtworkForm - Données initiales reçues:', { 
        mode,
        title: initialData?.title,
        description: initialData?.description
      })
    }
  }, [isEditMode, initialData])

  // Initialiser les images en mode édition si disponibles
  useEffect(() => {
    if (isEditMode && initialData?.imageUrl) {
      setPreviewImages([initialData.imageUrl])
    }
  }, [isEditMode, initialData])

  const {
    register,
    handleSubmit,
    setValue,
    reset,
    watch,
    formState: { errors }
  } = useForm<ArtworkFormData>({
    resolver: zodResolver(artworkSchema),
    defaultValues: {
      title: initialData?.title || '',
      description: initialData?.description || '',
      metaTitle: initialData?.metaTitle || '',
      metaDescription: initialData?.metaDescription || '',
      medium: initialData?.medium || '',
      width: initialData?.width || '',
      height: initialData?.height || '',
      weight: initialData?.weight || '',
      year: initialData?.year || new Date().getFullYear().toString(),
      creationYear: initialData?.creationYear || '',
      intellectualProperty: initialData?.intellectualProperty || false,
      intellectualPropertyEndDate: initialData?.intellectualPropertyEndDate || '',
      edition: initialData?.edition || '',
      images: undefined,
      certificate: undefined,
      hasPhysicalOnly: initialData?.hasPhysicalOnly || false,
      hasNftOnly: initialData?.hasNftOnly || false,
      hasNftPlusPhysical: initialData?.hasNftPlusPhysical || false,
      pricePhysicalBeforeTax: initialData?.pricePhysicalBeforeTax || '',
      priceNftBeforeTax: initialData?.priceNftBeforeTax || '',
      priceNftPlusPhysicalBeforeTax: initialData?.priceNftPlusPhysicalBeforeTax || ''
    }
  })
  
  // Observer la valeur de la propriété intellectuelle
  const intellectualProperty = watch('intellectualProperty')
  
  // Observer les options de tarification pour les œuvres physiques
  const hasPhysicalOnly = watch('hasPhysicalOnly');
  const hasNftPlusPhysical = watch('hasNftPlusPhysical');
  const hasNftOnly = watch('hasNftOnly');
  const hasPhysicalArtwork = hasPhysicalOnly || hasNftPlusPhysical;
  
  // Observer la valeur du titre pour générer le slug automatiquement
  const title = watch('title')
  
  useEffect(() => {
    if (title) {
      setSlug(normalizeString(title))
    }
  }, [title])
  
  // Définir les options du toast avec fond rouge clair
  const toastErrorOptions = {
    duration: 5000,
    position: 'top-center' as const,
    style: {
      background: '#FFEBEE', // Fond rouge clair
      color: '#D32F2F',       // Texte rouge foncé
      border: '1px solid #FFCDD2', // Bordure rouge clair
      fontWeight: 500,
      padding: '16px',
    },
    icon: '⚠️',
  };

  // Mettre à jour l'état local quand le champ change
  useEffect(() => {
    setHasIntellectualProperty(!!intellectualProperty)
  }, [intellectualProperty])
  
  useEffect(() => {
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors)
      console.log('Erreurs de validation détectées:', errors)
      
      // Mappez les noms de champs pour un affichage plus convivial
      const fieldNames: Record<string, string> = {
        title: 'Titre',
        description: 'Description',
        pricePhysicalBeforeTax: 'Prix - Oeuvre physique',
        priceNftBeforeTax: 'Prix - NFT',
        priceNftPlusPhysicalBeforeTax: 'Prix - NFT + Oeuvre physique',
        pricingOption: 'Option de tarification',
        medium: 'Support/Medium',
        images: 'Images',
        certificate: 'Certificat d\'authenticité',
        width: 'Largeur',
        height: 'Hauteur',
        weight: 'Poids',
        root: 'Général',
        physicalDimensions: 'Dimensions physiques (poids, largeur, hauteur)'
      }
      
      // Vérifier les différents types d'erreurs spécifiques
      const hasPricingOptionError = errors.root?.message && 
                                  typeof errors.root.message === 'string' && 
                                  errors.root.message.includes("option de tarification");
      
      const hasPhysicalDimensionsError = errors.root?.message && 
                                        typeof errors.root.message === 'string' && 
                                        errors.root.message.includes("dimensions");
      
      const hasPriceError = errors.pricePhysicalBeforeTax?.message || 
                           errors.priceNftBeforeTax?.message || 
                           errors.priceNftPlusPhysicalBeforeTax?.message;
      
      // Afficher l'erreur selon sa priorité
      if (hasPricingOptionError && errors.root?.message) {
        toast.error(String(errors.root.message), toastErrorOptions);
      } else if (hasPriceError) {
        // Afficher l'erreur de prix spécifique
        if (errors.pricePhysicalBeforeTax?.message) {
          toast.error(String(errors.pricePhysicalBeforeTax.message), toastErrorOptions);
        } else if (errors.priceNftBeforeTax?.message) {
          toast.error(String(errors.priceNftBeforeTax.message), toastErrorOptions);
        } else if (errors.priceNftPlusPhysicalBeforeTax?.message) {
          toast.error(String(errors.priceNftPlusPhysicalBeforeTax.message), toastErrorOptions);
        }
      } else if (hasPhysicalDimensionsError && errors.root?.message) {
        // Message d'erreur pour les dimensions physiques
        toast.error(String(errors.root.message), toastErrorOptions);
      } else {
        // Collecter les noms des champs en erreur
        const missingFields = Object.keys(errors)
          .map(key => fieldNames[key])
          .filter(Boolean);
        
        if (missingFields.length > 0) {
          // Afficher la liste des champs manquants
          toast.error(`Champs obligatoires manquants : ${missingFields.join(', ')}`, toastErrorOptions);
        }
      }
      
      // Faire défiler jusqu'au premier champ en erreur
      const firstError = Object.keys(errors)[0]
      const element = document.getElementById(firstError)
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' })
        element.focus()
      }
    } else {
      setFormErrors(null)
    }
  }, [errors])
  
  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (!files) return
    
    // Prévisualisation des images
    const imageFiles = Array.from(files)
    const imageUrls: string[] = []
    
    imageFiles.forEach(file => {
      const url = URL.createObjectURL(file)
      imageUrls.push(url)
    })
    
    setPreviewImages(imageUrls)
  }
  
  const handleSecondaryImagesChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (!files) return
    
    // Ajouter les nouvelles images aux images secondaires existantes
    const newImageFiles = Array.from(files)
    const newImageUrls: string[] = []
    
    newImageFiles.forEach(file => {
      const url = URL.createObjectURL(file)
      newImageUrls.push(url)
    })
    
    setSecondaryImages(prev => [...prev, ...newImageUrls])
  }
  
  const removeSecondaryImage = (index: number) => {
    setSecondaryImages(prev => prev.filter((_, i) => i !== index))
  }
  
  const handleCertificateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (!files || files.length === 0) {
      setPreviewCertificate(null)
      setValue('certificate', null, { shouldValidate: true })
      return
    }
    
    const file = files[0]
    if (file.type !== 'application/pdf') {
      toast.error('Seuls les fichiers PDF sont acceptés pour le certificat d\'authenticité')
      if (certificateInputRef.current) {
        certificateInputRef.current.value = ''
      }
      setPreviewCertificate(null)
      setValue('certificate', null, { shouldValidate: true })
      return
    }
    
    const url = URL.createObjectURL(file)
    setPreviewCertificate(url)
    
    // Important: définir manuellement la valeur pour react-hook-form
    setValue('certificate', e.target.files, { shouldValidate: true })
  }
  
  const onDocumentLoadSuccess = ({ numPages }: { numPages: number }) => {
    setNumPages(numPages)
  }
  
  const onSubmit = async (data: ArtworkFormData) => {
    setIsSubmitting(true)
    
    try {
      if (!user?.email) {
        throw new Error('Vous devez être connecté pour créer ou modifier une œuvre')
      }
      
      // Récupérer l'utilisateur du backoffice par email
      const backofficeUser = await getBackofficeUserByEmail(user.email)
      
      if (!backofficeUser) {
        throw new Error('Utilisateur non trouvé dans le backoffice')
      }
        
      if (isEditMode && initialData?.id) {
        // TODO: Implémenter la logique de mise à jour de l'œuvre
        toast.success('Mise à jour de l\'œuvre en cours de développement')
        
        // Pour la mise à jour, on utilise également name et description pour le titre et la description
        console.log('Mise à jour de l\'œuvre avec les propriétés:', {
          id: initialData.id,
          name: data.title, // Le titre va dans name
          description: data.description,
          metaTitle: data.metaTitle,
          metaDescription: data.metaDescription,
          // Autres propriétés...
          slug // On conserve aussi le slug
        })
        
        // Simuler un succès pour le prototype
        setTimeout(() => {
          if (onSuccess) onSuccess()
        }, 2000)
      } else {
        const formData = new FormData()
        
        // Ajouter les champs textuels
        Object.entries(data).forEach(([key, value]) => {
          if (key !== 'images' && key !== 'certificate' && key !== 'tags' && value !== undefined) {
            if (key === 'intellectualPropertyEndDate') {
              if (value) {
                formData.append(key, new Date(value as string).toISOString())
              }
            } else {
              formData.append(key, String(value))
            }
          }
        })
        
        // Ajouter les tags
        if (tags.length > 0) {
          formData.append('tags', tags.join(','))
        }
        
        // TODO: Uploader les images vers Firebase Storage
        // 1. Récupérer l'artiste associé à l'utilisateur
        // 2. Vérifier/créer le répertoire "Prénom Nom" de l'artiste
        // 3. Créer le répertoire avec le slug de l'item
        // 4. Uploader les images dans ce répertoire
        // 5. Récupérer les URLs des images

        // Simuler l'upload vers Firebase Storage (à implémenter réellement plus tard)
        console.log('💡 À implémenter: Upload des images vers Firebase Storage')
        console.log(`- Créer le dossier avec le nom de l'artiste s'il n'existe pas`)
        console.log(`- Créer le sous-dossier avec le slug "${slug}"`)
        console.log(`- Uploader les images dans ce répertoire`)
        console.log(`- Stocker les URLs dans mainImageUrl et images[]`)
        
        // Ajouter les images
        if (data.images && data.images instanceof FileList && data.images.length > 0) {
          Array.from(data.images).forEach((file, index) => {
            formData.append(`image-${index}`, file)
          })
        }
        
        // Ajouter le certificat
        if (data.certificate && data.certificate instanceof FileList && data.certificate.length > 0) {
          formData.append('certificate', data.certificate[0])
        }
        
        // Ajouter l'email
        formData.append('userEmail', user?.email || '')
        
        // Création du produit
        const result = {
          success: true,
        }

        if (result.success) {
          try {
            // Préparer le tableau d'images secondaires (pour la démo)
            const secondaryImagesArray = secondaryImages.map((url, index) => ({
              url,
              order: index + 1
            }))
            
            const newItem = await createItemRecord(
              backofficeUser.id, 
              'created',
              tags,
              {
                name: data.title,
                height: data.height ? parseFloat(data.height) : undefined,
                width: data.width ? parseFloat(data.width) : undefined,
                intellectualProperty: data.intellectualProperty,
                intellectualPropertyEndDate: data.intellectualPropertyEndDate ? new Date(data.intellectualPropertyEndDate) : null,
                creationYear: data.creationYear ? parseInt(data.creationYear, 10) : null,
                pricePhysicalBeforeTax: data.hasPhysicalOnly && data.pricePhysicalBeforeTax ? parseInt(data.pricePhysicalBeforeTax, 10) : 0,
                priceNftBeforeTax: data.hasNftOnly && data.priceNftBeforeTax ? parseInt(data.priceNftBeforeTax, 10) : 0,
                priceNftPlusPhysicalBeforeTax: data.hasNftPlusPhysical && data.priceNftPlusPhysicalBeforeTax ? parseInt(data.priceNftPlusPhysicalBeforeTax, 10) : 0,
                artworkSupport: data.medium || null,
                metaTitle: data.metaTitle,
                metaDescription: data.metaDescription
                // Les propriétés imageUrl et images qui causent des erreurs ont été retirées temporairement
                // Une fois le schéma de la table mis à jour, on pourra les ajouter
                // imageUrl: previewImages[0] || null,
                // images: secondaryImagesArray
              }
            )
            
            // Si la création de l'item a réussi et que nous avons un certificat
            if (newItem && newItem.item.id && data.certificate && data.certificate instanceof FileList && data.certificate.length > 0) {
              const certificateFile = data.certificate[0];
              const arrayBuffer = await certificateFile.arrayBuffer();
              const buffer = new Uint8Array(arrayBuffer)
              await saveAuthCertificate(newItem.item.id, buffer)
            }
            
            // Enregistrer le slug dans les logs pour utilisation future
            console.log(`Œuvre "${data.title}" créée avec succès. Slug généré: ${slug}`)
            console.log(`Images secondaires: ${secondaryImagesArray.length}`)
            
            toast.success(`L'œuvre "${data.title}" a été créée avec succès!`)
            
            if (onSuccess) {
              onSuccess()
            } else {
              handleResetForm()
            }
          } catch (itemError) {
            console.error('Erreur lors de la création de l\'item:', itemError)
            toast.error('Erreur lors de la création de l\'item')
          }
        }
      }
    } catch (error: any) {
      console.error('Erreur lors de la soumission du formulaire:', error)
      toast.error(error.message || 'Une erreur est survenue')
    } finally {
      setIsSubmitting(false)
    }
  }
  
  const handleResetForm = () => {
    reset()
    setPreviewImages([])
    setPreviewCertificate(null)
    setTags([])
    setSecondaryImages([])
    if (fileInputRef.current) {
      fileInputRef.current.value = ''
    }
    if (certificateInputRef.current) {
      certificateInputRef.current.value = ''
    }
    if (secondaryImagesInputRef.current) {
      secondaryImagesInputRef.current.value = ''
    }
  }
  
  return (
    <form onSubmit={handleSubmit(onSubmit)} className={styles.form}>
      {/* Artwork Information */}
      <section className={styles.formSectionContent}>
        <div className="flex items-center gap-2">
          <h2 className={styles.formSectionTitle}>Informations sur l'œuvre</h2>
          <InfoTooltip title="Aide" content="Informations générales sur l'œuvre" />
        </div>

        <div className={styles.formGrid}>
          {/* Title */}
          <div className={styles.formGroup}>
            <label htmlFor="title" className={styles.formLabel} data-required={true}>
              Titre
            </label>
            <input
              id="title"
              type="text"
              {...register("title", { required: true })}
              className={`${styles.formInput} ${errors.title ? styles.formInputError : ''}`}
              placeholder="Entrez le titre de l'œuvre"
            />
            {errors.title && <p className={styles.formError}>Le titre est requis</p>}
          </div>

          {/* Artist */}
          <div className={styles.formGroup}>
            <label htmlFor="artistId" className={styles.formLabel} data-required={true}>
              Artiste
            </label>
            <select
              id="artistId"
              {...register("artistId", { required: true })}
              className={`${styles.formSelect} ${errors.artistId ? styles.formInputError : ''}`}
            >
              <option value="">Sélectionnez un artiste</option>
              {/* Add artist options here */}
            </select>
            {errors.artistId && <p className={styles.formError}>L'artiste est requis</p>}
          </div>
'use client'

import { useState, useRef, useEffect } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { artworkSchema, ArtworkFormData } from '../createArtwork/schema'
import { createArtwork } from '@/lib/actions/shopify-actions'
import toast from 'react-hot-toast'
import { useDynamicContext } from '@dynamic-labs/sdk-react-core'
import styles from './ArtworkForm.module.scss'
import { getBackofficeUserByEmail, createItemRecord, saveAuthCertificate } from '@/lib/actions/prisma-actions'
import { pdfjs } from 'react-pdf'
import { Document, Page } from 'react-pdf'
import 'react-pdf/dist/esm/Page/AnnotationLayer.css'
import 'react-pdf/dist/esm/Page/TextLayer.css'
import { TagInput } from '@/app/components/Tag/TagInput'
import { normalizeString } from '@/lib/utils'
// Imports qui causent des erreurs - à supprimer
// import { Button } from '@/components/ui/button'
// import { Loader2Icon, UploadIcon, XIcon } from 'lucide-react'
// import { useRouter } from 'next/navigation'

// Configuration du worker PDF.js (nécessaire pour react-pdf)
pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.min.js`

// Composant InfoTooltip pour afficher des conseils détaillés
interface InfoTooltipProps {
  title: string;
  content: React.ReactNode;
}

function InfoTooltip({ title, content }: InfoTooltipProps) {
  const [isOpen, setIsOpen] = useState(false);
  const tooltipRef = useRef<HTMLDivElement>(null);

  // Fermer l'infobulle en cliquant à l'extérieur
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (tooltipRef.current && !tooltipRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  return (
    <div className={styles.tooltipContainer} ref={tooltipRef}>
      <span 
        className={styles.infoIcon} 
        onClick={() => setIsOpen(!isOpen)}
        aria-label={title}
      >
        ?
      </span>
      {isOpen && (
        <div className={styles.tooltipContent}>
          <div className={styles.tooltipHeader}>
            <h4>{title}</h4>
            <button 
              className={styles.closeTooltip}
              onClick={() => setIsOpen(false)}
              aria-label="Fermer"
            >
              ×
            </button>
          </div>
          <div className={styles.tooltipBody}>
            {content}
          </div>
        </div>
      )}
    </div>
  );
}

interface ArtworkFormProps {
  mode: 'create' | 'edit';
  initialData?: {
    id?: number;
    title?: string;
    description?: string;
    price?: number;
    metaTitle?: string;
    metaDescription?: string;
    medium?: string;
    width?: string;
    height?: string;
    weight?: string;
    year?: string;
    creationYear?: string;
    intellectualProperty?: boolean;
    intellectualPropertyEndDate?: string;
    edition?: string;
    imageUrl?: string;
    hasPhysicalOnly?: boolean;
    hasNftOnly?: boolean;
    hasNftPlusPhysical?: boolean;
    pricePhysicalBeforeTax?: string;
    priceNftBeforeTax?: string;
    priceNftPlusPhysicalBeforeTax?: string;
    slug?: string;
  };
  onSuccess?: () => void;
}

export default function ArtworkForm({ mode = 'create', initialData = {}, onSuccess }: ArtworkFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [previewImages, setPreviewImages] = useState<string[]>([])
  const [previewCertificate, setPreviewCertificate] = useState<string | null>(null)
  const [numPages, setNumPages] = useState<number | null>(null)
  const [tags, setTags] = useState<string[]>([])
  const [hasIntellectualProperty, setHasIntellectualProperty] = useState(initialData?.intellectualProperty || false)
  const [slug, setSlug] = useState(initialData?.slug || '')
  const fileInputRef = useRef<HTMLInputElement>(null)
  const certificateInputRef = useRef<HTMLInputElement>(null)
  const secondaryImagesInputRef = useRef<HTMLInputElement>(null)
  const [secondaryImages, setSecondaryImages] = useState<string[]>([])
  const { user } = useDynamicContext()
  const [formErrors, setFormErrors] = useState<any>(null)
  const isEditMode = mode === 'edit'
  
  // Log pour vérifier les données initiales
  useEffect(() => {
    if (isEditMode) {
      console.log('ArtworkForm - Données initiales reçues:', { 
        mode,
        title: initialData?.title,
        description: initialData?.description
      })
    }
  }, [isEditMode, initialData])

  // Initialiser les images en mode édition si disponibles
  useEffect(() => {
    if (isEditMode && initialData?.imageUrl) {
      setPreviewImages([initialData.imageUrl])
    }
  }, [isEditMode, initialData])

  const {
    register,
    handleSubmit,
    setValue,
    reset,
    watch,
    formState: { errors }
  } = useForm<ArtworkFormData>({
    resolver: zodResolver(artworkSchema),
    defaultValues: {
      title: initialData?.title || '',
      description: initialData?.description || '',
      metaTitle: initialData?.metaTitle || '',
      metaDescription: initialData?.metaDescription || '',
      medium: initialData?.medium || '',
      width: initialData?.width || '',
      height: initialData?.height || '',
      weight: initialData?.weight || '',
      year: initialData?.year || new Date().getFullYear().toString(),
      creationYear: initialData?.creationYear || '',
      intellectualProperty: initialData?.intellectualProperty || false,
      intellectualPropertyEndDate: initialData?.intellectualPropertyEndDate || '',
      edition: initialData?.edition || '',
      images: undefined,
      certificate: undefined,
      hasPhysicalOnly: initialData?.hasPhysicalOnly || false,
      hasNftOnly: initialData?.hasNftOnly || false,
      hasNftPlusPhysical: initialData?.hasNftPlusPhysical || false,
      pricePhysicalBeforeTax: initialData?.pricePhysicalBeforeTax || '',
      priceNftBeforeTax: initialData?.priceNftBeforeTax || '',
      priceNftPlusPhysicalBeforeTax: initialData?.priceNftPlusPhysicalBeforeTax || ''
    }
  })
  
  // Observer la valeur de la propriété intellectuelle
  const intellectualProperty = watch('intellectualProperty')
  
  // Observer les options de tarification pour les œuvres physiques
  const hasPhysicalOnly = watch('hasPhysicalOnly');
  const hasNftPlusPhysical = watch('hasNftPlusPhysical');
  const hasNftOnly = watch('hasNftOnly');
  const hasPhysicalArtwork = hasPhysicalOnly || hasNftPlusPhysical;
  
  // Observer la valeur du titre pour générer le slug automatiquement
  const title = watch('title')
  
  useEffect(() => {
    if (title) {
      setSlug(normalizeString(title))
    }
  }, [title])
  
  // Définir les options du toast avec fond rouge clair
  const toastErrorOptions = {
    duration: 5000,
    position: 'top-center' as const,
    style: {
      background: '#FFEBEE', // Fond rouge clair
      color: '#D32F2F',       // Texte rouge foncé
      border: '1px solid #FFCDD2', // Bordure rouge clair
      fontWeight: 500,
      padding: '16px',
    },
    icon: '⚠️',
  };

  // Mettre à jour l'état local quand le champ change
  useEffect(() => {
    setHasIntellectualProperty(!!intellectualProperty)
  }, [intellectualProperty])
  
  useEffect(() => {
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors)
      console.log('Erreurs de validation détectées:', errors)
      
      // Mappez les noms de champs pour un affichage plus convivial
      const fieldNames: Record<string, string> = {
        title: 'Titre',
        description: 'Description',
        pricePhysicalBeforeTax: 'Prix - Oeuvre physique',
        priceNftBeforeTax: 'Prix - NFT',
        priceNftPlusPhysicalBeforeTax: 'Prix - NFT + Oeuvre physique',
        pricingOption: 'Option de tarification',
        medium: 'Support/Medium',
        images: 'Images',
        certificate: 'Certificat d\'authenticité',
        width: 'Largeur',
        height: 'Hauteur',
        weight: 'Poids',
        root: 'Général',
        physicalDimensions: 'Dimensions physiques (poids, largeur, hauteur)'
      }
      
      // Vérifier les différents types d'erreurs spécifiques
      const hasPricingOptionError = errors.root?.message && 
                                  typeof errors.root.message === 'string' && 
                                  errors.root.message.includes("option de tarification");
      
      const hasPhysicalDimensionsError = errors.root?.message && 
                                        typeof errors.root.message === 'string' && 
                                        errors.root.message.includes("dimensions");
      
      const hasPriceError = errors.pricePhysicalBeforeTax?.message || 
                           errors.priceNftBeforeTax?.message || 
                           errors.priceNftPlusPhysicalBeforeTax?.message;
      
      // Afficher l'erreur selon sa priorité
      if (hasPricingOptionError && errors.root?.message) {
        toast.error(String(errors.root.message), toastErrorOptions);
      } else if (hasPriceError) {
        // Afficher l'erreur de prix spécifique
        if (errors.pricePhysicalBeforeTax?.message) {
          toast.error(String(errors.pricePhysicalBeforeTax.message), toastErrorOptions);
        } else if (errors.priceNftBeforeTax?.message) {
          toast.error(String(errors.priceNftBeforeTax.message), toastErrorOptions);
        } else if (errors.priceNftPlusPhysicalBeforeTax?.message) {
          toast.error(String(errors.priceNftPlusPhysicalBeforeTax.message), toastErrorOptions);
        }
      } else if (hasPhysicalDimensionsError && errors.root?.message) {
        // Message d'erreur pour les dimensions physiques
        toast.error(String(errors.root.message), toastErrorOptions);
      } else {
        // Collecter les noms des champs en erreur
        const missingFields = Object.keys(errors)
          .map(key => fieldNames[key])
          .filter(Boolean);
        
        if (missingFields.length > 0) {
          // Afficher la liste des champs manquants
          toast.error(`Champs obligatoires manquants : ${missingFields.join(', ')}`, toastErrorOptions);
        }
      }
      
      // Faire défiler jusqu'au premier champ en erreur
      const firstError = Object.keys(errors)[0]
      const element = document.getElementById(firstError)
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' })
        element.focus()
      }
    } else {
      setFormErrors(null)
    }
  }, [errors])
  
  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (!files) return
    
    // Prévisualisation des images
    const imageFiles = Array.from(files)
    const imageUrls: string[] = []
    
    imageFiles.forEach(file => {
      const url = URL.createObjectURL(file)
      imageUrls.push(url)
    })
    
    setPreviewImages(imageUrls)
  }
  
  const handleSecondaryImagesChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (!files) return
    
    // Ajouter les nouvelles images aux images secondaires existantes
    const newImageFiles = Array.from(files)
    const newImageUrls: string[] = []
    
    newImageFiles.forEach(file => {
      const url = URL.createObjectURL(file)
      newImageUrls.push(url)
    })
    
    setSecondaryImages(prev => [...prev, ...newImageUrls])
  }
  
  const removeSecondaryImage = (index: number) => {
    setSecondaryImages(prev => prev.filter((_, i) => i !== index))
  }
  
  const handleCertificateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (!files || files.length === 0) {
      setPreviewCertificate(null)
      setValue('certificate', null, { shouldValidate: true })
      return
    }
    
    const file = files[0]
    if (file.type !== 'application/pdf') {
      toast.error('Seuls les fichiers PDF sont acceptés pour le certificat d\'authenticité')
      if (certificateInputRef.current) {
        certificateInputRef.current.value = ''
      }
      setPreviewCertificate(null)
      setValue('certificate', null, { shouldValidate: true })
      return
    }
    
    const url = URL.createObjectURL(file)
    setPreviewCertificate(url)
    
    // Important: définir manuellement la valeur pour react-hook-form
    setValue('certificate', e.target.files, { shouldValidate: true })
  }
  
  const onDocumentLoadSuccess = ({ numPages }: { numPages: number }) => {
    setNumPages(numPages)
  }
  
  const onSubmit = async (data: ArtworkFormData) => {
    setIsSubmitting(true)
    
    try {
      if (!user?.email) {
        throw new Error('Vous devez être connecté pour créer ou modifier une œuvre')
      }
      
      // Récupérer l'utilisateur du backoffice par email
      const backofficeUser = await getBackofficeUserByEmail(user.email)
      
      if (!backofficeUser) {
        throw new Error('Utilisateur non trouvé dans le backoffice')
      }
        
      if (isEditMode && initialData?.id) {
        // TODO: Implémenter la logique de mise à jour de l'œuvre
        toast.success('Mise à jour de l\'œuvre en cours de développement')
        
        // Pour la mise à jour, on utilise également name et description pour le titre et la description
        console.log('Mise à jour de l\'œuvre avec les propriétés:', {
          id: initialData.id,
          name: data.title, // Le titre va dans name
          description: data.description,
          metaTitle: data.metaTitle,
          metaDescription: data.metaDescription,
          // Autres propriétés...
          slug // On conserve aussi le slug
        })
        
        // Simuler un succès pour le prototype
        setTimeout(() => {
          if (onSuccess) onSuccess()
        }, 2000)
      } else {
        const formData = new FormData()
        
        // Ajouter les champs textuels
        Object.entries(data).forEach(([key, value]) => {
          if (key !== 'images' && key !== 'certificate' && key !== 'tags' && value !== undefined) {
            if (key === 'intellectualPropertyEndDate') {
              if (value) {
                formData.append(key, new Date(value as string).toISOString())
              }
            } else {
              formData.append(key, String(value))
            }
          }
        })
        
        // Ajouter les tags
        if (tags.length > 0) {
          formData.append('tags', tags.join(','))
        }
        
        // TODO: Uploader les images vers Firebase Storage
        // 1. Récupérer l'artiste associé à l'utilisateur
        // 2. Vérifier/créer le répertoire "Prénom Nom" de l'artiste
        // 3. Créer le répertoire avec le slug de l'item
        // 4. Uploader les images dans ce répertoire
        // 5. Récupérer les URLs des images

        // Simuler l'upload vers Firebase Storage (à implémenter réellement plus tard)
        console.log('💡 À implémenter: Upload des images vers Firebase Storage')
        console.log(`- Créer le dossier avec le nom de l'artiste s'il n'existe pas`)
        console.log(`- Créer le sous-dossier avec le slug "${slug}"`)
        console.log(`- Uploader les images dans ce répertoire`)
        console.log(`- Stocker les URLs dans mainImageUrl et images[]`)
        
        // Ajouter les images
        if (data.images && data.images instanceof FileList && data.images.length > 0) {
          Array.from(data.images).forEach((file, index) => {
            formData.append(`image-${index}`, file)
          })
        }
        
        // Ajouter le certificat
        if (data.certificate && data.certificate instanceof FileList && data.certificate.length > 0) {
          formData.append('certificate', data.certificate[0])
        }
        
        // Ajouter l'email
        formData.append('userEmail', user?.email || '')
        
        // Création du produit
        const result = {
          success: true,
        }

        if (result.success) {
          try {
            // Préparer le tableau d'images secondaires (pour la démo)
            const secondaryImagesArray = secondaryImages.map((url, index) => ({
              url,
              order: index + 1
            }))
            
            const newItem = await createItemRecord(
              backofficeUser.id, 
              'created',
              tags,
              {
                name: data.title,
                height: data.height ? parseFloat(data.height) : undefined,
                width: data.width ? parseFloat(data.width) : undefined,
                intellectualProperty: data.intellectualProperty,
                intellectualPropertyEndDate: data.intellectualPropertyEndDate ? new Date(data.intellectualPropertyEndDate) : null,
                creationYear: data.creationYear ? parseInt(data.creationYear, 10) : null,
                pricePhysicalBeforeTax: data.hasPhysicalOnly && data.pricePhysicalBeforeTax ? parseInt(data.pricePhysicalBeforeTax, 10) : 0,
                priceNftBeforeTax: data.hasNftOnly && data.priceNftBeforeTax ? parseInt(data.priceNftBeforeTax, 10) : 0,
                priceNftPlusPhysicalBeforeTax: data.hasNftPlusPhysical && data.priceNftPlusPhysicalBeforeTax ? parseInt(data.priceNftPlusPhysicalBeforeTax, 10) : 0,
                artworkSupport: data.medium || null,
                metaTitle: data.metaTitle,
                metaDescription: data.metaDescription
                // Les propriétés imageUrl et images qui causent des erreurs ont été retirées temporairement
                // Une fois le schéma de la table mis à jour, on pourra les ajouter
                // imageUrl: previewImages[0] || null,
                // images: secondaryImagesArray
              }
            )
            
            // Si la création de l'item a réussi et que nous avons un certificat
            if (newItem && newItem.item.id && data.certificate && data.certificate instanceof FileList && data.certificate.length > 0) {
              const certificateFile = data.certificate[0];
              const arrayBuffer = await certificateFile.arrayBuffer();
              const buffer = new Uint8Array(arrayBuffer)
              await saveAuthCertificate(newItem.item.id, buffer)
            }
            
            // Enregistrer le slug dans les logs pour utilisation future
            console.log(`Œuvre "${data.title}" créée avec succès. Slug généré: ${slug}`)
            console.log(`Images secondaires: ${secondaryImagesArray.length}`)
            
            toast.success(`L'œuvre "${data.title}" a été créée avec succès!`)
            
            if (onSuccess) {
              onSuccess()
            } else {
              handleResetForm()
            }
          } catch (itemError) {
            console.error('Erreur lors de la création de l\'item:', itemError)
            toast.error('Erreur lors de la création de l\'item')
          }
        }
      }
    } catch (error: any) {
      console.error('Erreur lors de la soumission du formulaire:', error)
      toast.error(error.message || 'Une erreur est survenue')
    } finally {
      setIsSubmitting(false)
    }
  }
  
  const handleResetForm = () => {
    reset()
    setPreviewImages([])
    setPreviewCertificate(null)
    setTags([])
    setSecondaryImages([])
    if (fileInputRef.current) {
      fileInputRef.current.value = ''
    }
    if (certificateInputRef.current) {
      certificateInputRef.current.value = ''
    }
    if (secondaryImagesInputRef.current) {
      secondaryImagesInputRef.current.value = ''
    }
  }
  
  return (
    <form onSubmit={handleSubmit(onSubmit)} className={styles.form}>
      {/* Artwork Information */}
      <section className={styles.formSectionContent}>
        <div className="flex items-center gap-2">
          <h2 className={styles.formSectionTitle}>Informations sur l'œuvre</h2>
          <InfoTooltip title="Aide" content="Informations générales sur l'œuvre" />
        </div>

        <div className={styles.formGrid}>
          {/* Title */}
          <div className={styles.formGroup}>
            <label htmlFor="title" className={styles.formLabel} data-required={true}>
              Titre
            </label>
            <input
              id="title"
              type="text"
              {...register("title", { required: true })}
              className={`${styles.formInput} ${errors.title ? styles.formInputError : ''}`}
              placeholder="Entrez le titre de l'œuvre"
            />
            {errors.title && <p className={styles.formError}>Le titre est requis</p>}
          </div>

          {/* Artist */}
          <div className={styles.formGroup}>
            <label htmlFor="artistId" className={styles.formLabel} data-required={true}>
              Artiste
            </label>
            <select
              id="artistId"
              {...register("artistId", { required: true })}
              className={`${styles.formSelect} ${errors.artistId ? styles.formInputError : ''}`}
            >
              <option value="">Sélectionnez un artiste</option>
              {/* Add artist options here */}
            </select>
            {errors.artistId && <p className={styles.formError}>L'artiste est requis</p>}
          </div>
        </div>

        <div className={styles.formGrid}>
          {/* Year */}
          <div className={styles.formGroup}>
            <label htmlFor="year" className={styles.formLabel}>
              Année de création
            </label>
            <input
              id="year"
              type="number"
              {...register("year", {
                validate: (value) =>
                  !value ||
                  (parseInt(value) >= 1800 && parseInt(value) <= new Date().getFullYear()) ||
                  "L'année doit être entre 1800 et l'année courante",
              })}
              className={`${styles.formInput} ${errors.year ? styles.formInputError : ''}`}
              placeholder="Entrez l'année de création"
            />
            {errors.year && <p className={styles.formError}>{errors.year.message}</p>}
          </div>

          {/* Medium */}
          <div className={styles.formGroup}>
            <label htmlFor="medium" className={styles.formLabel} data-required={true}>
              Médium / Support
            </label>
            <input
              id="medium"
              type="text"
              {...register("medium", { required: true })}
              className={`${styles.formInput} ${errors.medium ? styles.formInputError : ''}`}
              placeholder="Ex: Huile sur toile, Acrylique, etc."
            />
            {errors.medium && <p className={styles.formError}>Le médium est requis</p>}
          </div>
        </div>

        <div className={styles.formGrid}>
          {/* Width */}
          <div className={styles.formGroup}>
            <label htmlFor="width" className={styles.formLabel} data-required={true}>
              Largeur (cm)
            </label>
            <input
              id="width"
              type="number"
              step="0.01"
              {...register("width", {
                required: true,
                validate: (value) => !value || parseFloat(value) > 0 || "La largeur doit être supérieure à 0",
              })}
              className={`${styles.formInput} ${errors.width ? styles.formInputError : ''}`}
              placeholder="Largeur en cm"
            />
            {errors.width && <p className={styles.formError}>{errors.width.message || "La largeur est requise"}</p>}
          </div>

          {/* Height */}
          <div className={styles.formGroup}>
            <label htmlFor="height" className={styles.formLabel} data-required={true}>
              Hauteur (cm)
            </label>
            <input
              id="height"
              type="number"
              step="0.01"
              {...register("height", {
                required: true,
                validate: (value) => !value || parseFloat(value) > 0 || "La hauteur doit être supérieure à 0",
              })}
              className={`${styles.formInput} ${errors.height ? styles.formInputError : ''}`}
              placeholder="Hauteur en cm"
            />
            {errors.height && <p className={styles.formError}>{errors.height.message || "La hauteur est requise"}</p>}
          </div>

          {/* Depth */}
          <div className={styles.formGroup}>
            <label htmlFor="depth" className={styles.formLabel}>
              Profondeur (cm)
            </label>
            <input
              id="depth"
              type="number"
              step="0.01"
              {...register("depth", {
                validate: (value) => !value || parseFloat(value) >= 0 || "La profondeur doit être positive",
              })}
              className={`${styles.formInput} ${errors.depth ? styles.formInputError : ''}`}
              placeholder="Profondeur en cm (optionnel)"
            />
            {errors.depth && <p className={styles.formError}>{errors.depth.message}</p>}
          </div>
        </div>

        <div className={styles.formGrid}>
          {/* Price */}
          <div className={styles.formGroup}>
            <label htmlFor="price" className={styles.formLabel} data-required={true}>
              Prix (€)
            </label>
            <input
              id="price"
              type="number"
              step="0.01"
              {...register("price", {
                required: true,
                validate: (value) => !value || (typeof value === 'number' ? value > 0 : parseFloat(value) > 0) || "Le prix doit être supérieur à 0",
              })}
              className={`${styles.formInput} ${errors.price ? styles.formInputError : ''}`}
              placeholder="Prix en euros"
            />
            {errors.price && <p className={styles.formError}>{errors.price.message || "Le prix est requis"}</p>}
          </div>

          {/* Status */}
          <div className={styles.formGroup}>
            <label htmlFor="status" className={styles.formLabel} data-required={true}>
              Statut
            </label>
            <select
              id="status"
              {...register("status", { required: true })}
              className={`${styles.formSelect} ${errors.status ? styles.formInputError : ''}`}
            >
              <option value="">Sélectionnez un statut</option>
              <option value="available">Disponible</option>
              <option value="sold">Vendu</option>
              <option value="reserved">Réservé</option>
            </select>
            {errors.status && <p className={styles.formError}>Le statut est requis</p>}
          </div>
        </div>

        {/* Description */}
        <div className={styles.formGroup}>
          <label htmlFor="description" className={styles.formLabel}>
            Description
          </label>
          <textarea
            id="description"
            {...register("description")}
            className={`${styles.formTextarea} ${errors.description ? styles.formInputError : ''}`}
            rows={4}
            placeholder="Décrivez l'œuvre..."
          />
        </div>
        
        {/* Options de tarification */}
        <div className={styles.formSectionTitle}>Options de tarification</div>
        <div className={styles.formSectionContent}>
          {/* Options de type d'œuvre */}
          <div className={styles.formGroup}>
            <label className={styles.formLabel}>Type d'œuvre disponible</label>
            <div className={styles.pricingOptions}>
              {/* Option Œuvre physique uniquement */}
              <div className={styles.pricingOption}>
                <div className="flex items-center mb-2">
                  <input
                    type="checkbox"
                    id="hasPhysicalOnly"
                    {...register("hasPhysicalOnly")}
                    className="mr-2 h-4 w-4"
                  />
                  <label htmlFor="hasPhysicalOnly" className="font-medium">Œuvre physique uniquement</label>
                </div>
                {hasPhysicalOnly && (
                  <div className="mt-2">
                    <label htmlFor="pricePhysicalBeforeTax" className="block text-sm mb-1">Prix (€ HT)</label>
                    <input
                      type="text"
                      id="pricePhysicalBeforeTax"
                      {...register("pricePhysicalBeforeTax")}
                      className={`${styles.formInput} ${errors.pricePhysicalBeforeTax ? styles.formInputError : ''}`}
                      placeholder="Prix HT"
                    />
                    {errors.pricePhysicalBeforeTax && (
                      <p className={styles.formError}>{errors.pricePhysicalBeforeTax.message}</p>
                    )}
                  </div>
                )}
              </div>

              {/* Option NFT uniquement */}
              <div className={styles.pricingOption}>
                <div className="flex items-center mb-2">
                  <input
                    type="checkbox"
                    id="hasNftOnly"
                    {...register("hasNftOnly")}
                    className="mr-2 h-4 w-4"
                  />
                  <label htmlFor="hasNftOnly" className="font-medium">NFT uniquement</label>
                </div>
                {hasNftOnly && (
                  <div className="mt-2">
                    <label htmlFor="priceNftBeforeTax" className="block text-sm mb-1">Prix (€ HT)</label>
                    <input
                      type="text"
                      id="priceNftBeforeTax"
                      {...register("priceNftBeforeTax")}
                      className={`${styles.formInput} ${errors.priceNftBeforeTax ? styles.formInputError : ''}`}
                      placeholder="Prix HT"
                    />
                    {errors.priceNftBeforeTax && (
                      <p className={styles.formError}>{errors.priceNftBeforeTax.message}</p>
                    )}
                  </div>
                )}
              </div>

              {/* Option NFT + Œuvre physique */}
              <div className={styles.pricingOption}>
                <div className="flex items-center mb-2">
                  <input
                    type="checkbox"
                    id="hasNftPlusPhysical"
                    {...register("hasNftPlusPhysical")}
                    className="mr-2 h-4 w-4"
                  />
                  <label htmlFor="hasNftPlusPhysical" className="font-medium">NFT + Œuvre physique</label>
                </div>
                {hasNftPlusPhysical && (
                  <div className="mt-2">
                    <label htmlFor="priceNftPlusPhysicalBeforeTax" className="block text-sm mb-1">Prix (€ HT)</label>
                    <input
                      type="text"
                      id="priceNftPlusPhysicalBeforeTax"
                      {...register("priceNftPlusPhysicalBeforeTax")}
                      className={`${styles.formInput} ${errors.priceNftPlusPhysicalBeforeTax ? styles.formInputError : ''}`}
                      placeholder="Prix HT"
                    />
                    {errors.priceNftPlusPhysicalBeforeTax && (
                      <p className={styles.formError}>{errors.priceNftPlusPhysicalBeforeTax.message}</p>
                    )}
                  </div>
                )}
              </div>
            </div>
            {errors.root && typeof errors.root.message === 'string' && errors.root.message.includes("tarification") && (
              <p className={styles.formError}>Vous devez sélectionner au moins une option de tarification</p>
            )}
          </div>
        </div>
        
        {/* Propriété intellectuelle */}
        <div className={styles.formSectionTitle}>Propriété intellectuelle</div>
        <div className={styles.formSectionContent}>
          <div className={styles.formGroup}>
            <div className="flex items-center gap-2">
              <input
                type="checkbox"
                id="intellectualProperty"
                {...register("intellectualProperty")}
                className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
              />
              <label htmlFor="intellectualProperty" className={styles.formLabel}>
                Droits de la propriété intellectuelle
              </label>
              <InfoTooltip 
                title="Propriété intellectuelle" 
                content="Indiquez si l'œuvre est protégée par des droits de propriété intellectuelle" 
              />
            </div>
          </div>
          
          {/* Date de fin des droits - conditionnelle */}
          {hasIntellectualProperty && (
            <div className={styles.formGroup}>
              <label htmlFor="intellectualPropertyEndDate" className={styles.formLabel}>
                Date de fin des droits
              </label>
              <input
                type="date"
                id="intellectualPropertyEndDate"
                {...register("intellectualPropertyEndDate")}
                className={`${styles.formInput} ${errors.intellectualPropertyEndDate ? styles.formInputError : ''}`}
                min={new Date().toISOString().split('T')[0]}
              />
              {errors.intellectualPropertyEndDate && (
                <p className={styles.formError}>{errors.intellectualPropertyEndDate.message}</p>
              )}
            </div>
          )}
        </div>
        
        {/* Year Created */}
        <div className={styles.formGroup}>
          <div className="flex items-center gap-2">
            <label htmlFor="isYearEstimated" className={styles.formLabel}>
              Année estimée
            </label>
            <input
              type="checkbox"
              id="isYearEstimated"
              {...register("isYearEstimated")}
              className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
            />
            <InfoTooltip title="Année estimée" content="Cochez cette case si l'année de création est estimée" />
          </div>
        </div>
        
        {/* Année de création */}
        <div className={styles.formGroup}>
          <label htmlFor="creationYear" className={styles.formLabel}>
            Année de création
          </label>
          <input
            id="creationYear"
            type="text"
            {...register("creationYear")}
            className={`${styles.formInput} ${errors.creationYear ? styles.formInputError : ''}`}
            placeholder="Ex: 2023"
          />
          {errors.creationYear && <p className={styles.formError}>{errors.creationYear.message}</p>}
        </div>

        {/* Édition */}
        <div className={styles.formGroup}>
          <label htmlFor="edition" className={styles.formLabel}>
            Édition
          </label>
          <input
            id="edition"
            type="text"
            {...register("edition")}
            className={styles.formInput}
            placeholder="Ex: 1/10, Édition limitée, etc."
          />
        </div>

        {/* Framable */}
        <div className={styles.formGroup}>
          <div className="flex items-center gap-2">
            <input
              type="checkbox"
              id="framable"
              {...register("framable")}
              className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
            />
            <label htmlFor="framable" className={styles.formLabel}>
              Encadrable
            </label>
            <InfoTooltip title="Aide" content="L'œuvre peut-elle être encadrée ?" />
          </div>
        </div>

        {/* Is Framed */}
        <div className={styles.formGroup}>
          <div className="flex items-center gap-2">
            <input
              type="checkbox"
              id="isFramed"
              {...register("isFramed")}
              className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
            />
            <label htmlFor="isFramed" className={styles.formLabel}>
              Encadrée
            </label>
            <InfoTooltip title="Aide" content="L'œuvre est-elle déjà encadrée ?" />
          </div>
        </div>

        {/* Is Signed */}
        <div className={styles.formGroup}>
          <div className="flex items-center gap-2">
            <input
              type="checkbox"
              id="isSigned"
              {...register("isSigned")}
              className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
            />
            <label htmlFor="isSigned" className={styles.formLabel}>
              Signée
            </label>
            <InfoTooltip title="Aide" content="L'œuvre est-elle signée par l'artiste ?" />
          </div>
        </div>
      </section>
      
      {/* SEO */}
      <div className={styles.formSectionTitle}>SEO</div>
      <div className={styles.formSectionContent}>
        <div className={styles.formGroup}>
          <label htmlFor="metaTitle" className={styles.formLabel} data-required={true}>
            Titre SEO
          </label>
          <input
            id="metaTitle"
            type="text"
            {...register("metaTitle", { required: true })}
            className={`${styles.formInput} ${errors.metaTitle ? styles.formInputError : ''}`}
            placeholder="Titre optimisé pour les moteurs de recherche"
            maxLength={60}
          />
          {errors.metaTitle && <p className={styles.formError}>Le titre SEO est requis</p>}
          <p className="text-xs text-gray-500 mt-1">Maximum 60 caractères</p>
        </div>
        
        <div className={styles.formGroup}>
          <label htmlFor="metaDescription" className={styles.formLabel} data-required={true}>
            Description SEO
          </label>
          <textarea
            id="metaDescription"
            {...register("metaDescription", { required: true })}
            className={`${styles.formTextarea} ${errors.metaDescription ? styles.formInputError : ''}`}
            placeholder="Description optimisée pour les moteurs de recherche"
            maxLength={160}
            rows={3}
          />
          {errors.metaDescription && <p className={styles.formError}>La description SEO est requise</p>}
          <p className="text-xs text-gray-500 mt-1">Maximum 160 caractères</p>
        </div>
      </div>

      {/* Section Fichiers Media */}
      <div className={styles.formSectionTitle}>Fichiers Media</div>
      <div className={styles.formSectionContent}>
        {/* Image principale */}
        <div className={styles.formGroup}>
          <label htmlFor="images" className={styles.formLabel} data-required={true}>
            Image principale
          </label>
          <input
            id="images"
            type="file"
            accept="image/*"
            onChange={(e) => {
              handleImageChange(e)
              if (e.target.files) {
                setValue('images', e.target.files, { shouldValidate: true })
              }
            }}
            ref={fileInputRef}
            className={`${styles.formFileInput} ${errors.images ? styles.formInputError : ''}`}
          />
          {errors.images && (
            <p className={styles.formError}>{errors.images?.message ? String(errors.images.message) : 'L\'image principale est requise'}</p>
          )}
          
          {/* Prévisualisation de l'image principale */}
          {previewImages.length > 0 && (
            <div className={styles.imagePreviewContainer}>
              {previewImages.map((src, index) => (
                <div key={index} className={styles.imagePreview}>
                  <img src={src} alt={`Aperçu ${index + 1}`} />
                </div>
              ))}
            </div>
          )}
        </div>
        
        {/* Images secondaires */}
        <div className={styles.formGroup}>
          <label htmlFor="secondaryImages" className={styles.formLabel}>
            Images secondaires
            <InfoTooltip
              title="Images secondaires"
              content={
                <>
                  <p>Ajoutez des images supplémentaires pour montrer l'œuvre sous différents angles.</p>
                  <p>Vous pouvez ajouter autant d'images que nécessaire.</p>
                </>
              }
            />
          </label>
          <input
            id="secondaryImages"
            type="file"
            accept="image/*"
            multiple
            onChange={handleSecondaryImagesChange}
            ref={secondaryImagesInputRef}
            className={styles.formFileInput}
          />
          
          {/* Prévisualisation des images secondaires */}
          {secondaryImages.length > 0 && (
            <div className={styles.imagePreviewContainer}>
              {secondaryImages.map((src, index) => (
                <div key={index} className={styles.imagePreview}>
                  <img src={src} alt={`Image secondaire ${index + 1}`} />
                  <button
                    type="button"
                    onClick={() => removeSecondaryImage(index)}
                    className={styles.removeImageBtn}
                  >
                    ×
                  </button>
                </div>
              ))}
            </div>
          )}
        </div>
        
        {/* Certificat d'authenticité */}
        <div className={styles.formGroup}>
          <label htmlFor="certificate" className={styles.formLabel} data-required={true}>
            Certificat d'authenticité (PDF)
          </label>
          <input
            id="certificate"
            type="file"
            accept="application/pdf"
            onChange={(e) => {
              handleCertificateChange(e)
              if (e.target.files) {
                setValue('certificate', e.target.files, { shouldValidate: true })
              }
            }}
            ref={certificateInputRef}
            className={`${styles.formFileInput} ${errors.certificate ? styles.formInputError : ''}`}
          />
          {errors.certificate && (
            <p className={styles.formError}>{errors.certificate?.message ? String(errors.certificate.message) : 'Le certificat est requis'}</p>
          )}
          
          {/* Prévisualisation du certificat - version simplifiée */}
          {previewCertificate && (
            <div className={styles.certificatePreviewContainer}>
              <h4>Certificat d'authenticité sélectionné</h4>
              <div className={styles.certificateInfo}>
                <p>Format: PDF</p>
                <p>Nom: {certificateInputRef.current?.files?.[0]?.name || 'document.pdf'}</p>
                <p>Taille: {((certificateInputRef.current?.files?.[0]?.size || 0) / 1024).toFixed(2)} Ko</p>
                <a 
                  href={previewCertificate} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className={styles.viewPdfLink}
                >
                  Voir le PDF dans un nouvel onglet
                </a>
              </div>
            </div>
          )}
        </div>
      </div>
      
      {/* Additional Fields */}
      <section className={styles.formSectionContent}>
        <h2 className={styles.formSectionTitle}>Champs additionnels</h2>

        {/* Inventory Number */}
        <div className={styles.formGroup}>
          <label htmlFor="inventoryNumber" className={styles.formLabel}>
            Numéro d'inventaire
          </label>
          <input
            id="inventoryNumber"
            {...register("inventoryNumber")}
            className={styles.formInput}
            placeholder="Ex: ART-2023-001"
          />
        </div>

        {/* Is Featured */}
        <div className={styles.formGroup}>
          <div className="flex items-center gap-2">
            <input
              type="checkbox"
              id="isFeatured"
              {...register("isFeatured")}
              className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
            />
            <label htmlFor="isFeatured" className={styles.formLabel}>
              Œuvre mise en avant
            </label>
            <InfoTooltip title="Mise en avant" content="Cette œuvre sera mise en avant sur la page d'accueil" />
          </div>
        </div>
      </section>

      {/* Form Buttons */}
      <div className={styles.formActions}>
        <button 
          type="button" 
          className={styles.cancelButton}
          onClick={handleResetForm}
          disabled={isSubmitting}
        >
          Annuler
        </button>
        <button 
          type="submit" 
          className={styles.submitButton}
          disabled={isSubmitting}
        >
          {isSubmitting 
            ? (isEditMode ? 'Modification en cours...' : 'Création en cours...') 
            : (isEditMode ? 'Mettre à jour l\'œuvre' : 'Créer l\'œuvre')}
        </button>
      </div>
    </form>
  )
} 